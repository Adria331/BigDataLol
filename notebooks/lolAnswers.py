# -*- coding: utf-8 -*-
"""Sparking2bakupHd

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fB95qWm69IZKkJ_jOC-2hX0AdJS8lVpf
"""

!apt-get install openjdk-8-jdk-headless -qq > /dev/null
!wget -q https://www-us.apache.org/dist/spark/spark-2.4.3/spark-2.4.3-bin-hadoop2.7.tgz
!tar xf spark-2.4.3-bin-hadoop2.7.tgz
!pip install -q findspark

import os
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"
os.environ["SPARK_HOME"] = "/content/spark-2.4.3-bin-hadoop2.7"

import findspark
findspark.init()
from pyspark.sql import SparkSession
spark = SparkSession.builder.master("local[*]").getOrCreate()

import json
import shutil
import numpy as np
import functools
from pyspark.sql.functions import pandas_udf, PandasUDFType, explode
from operator import add
import matplotlib.pyplot as plt

sc = spark.sparkContext

"""##List of champs"""

with open('allChamps.json') as json_file:  
    champs = json.load(json_file)

idchampions = {}
for champion in champs :
  id = champs[champion]['key']
  idchampions[id] = champion

idchampions['6']

champs['Urgot']

idchampions

"""#GAME"""

game = spark.read.json("game.json")
game.show(3)

game.columns

game.printSchema()

"""##Most, less and none played champ"""

championIds2 = [df['championId'] for row in game.select("participants").collect() for df in row['participants']]

champsFiltered = sc.parallelize(championIds2).map(lambda word: (word, 1)).reduceByKey(lambda a,b:a +b).sortBy(lambda x:x[1], ascending=False).collect()

mostPlayed = champsFiltered[0]
lessPlayed = champsFiltered[-1]
print("Most played: " + idchampions[str(mostPlayed[0])] + " " + str(mostPlayed[1]) + " times played")
print("Less played: " + idchampions[str(lessPlayed[0])] + " " + str(lessPlayed[1]) + " times played")

champsFiltered

plt.xlabel("Champion")
plt.ylabel("Number times played")

topChamps = 10

x = np.array([i+1 for i in range(topChamps)])

my_xticks = [idchampions[str(champsFiltered[i][0])] for i in range(topChamps)]
plt.xticks(x, my_xticks)

for i in range(topChamps):
  plt.bar(i+1, champsFiltered[i][1], width=0.8, align='center' )

fig_size = plt.rcParams["figure.figsize"]
fig_size[0] =10
fig_size[1] =10
plt.rcParams["figure.figsize"] = fig_size
plt.show()

nonPlayed = []
allPlayed = [idc[0] for idc in champsFiltered]
for id in idchampions.keys() :
  if int(id) not in allPlayed :
    nonPlayed.append(idchampions[id])
    
print("Non-played champions:\n")
nonPlayed

"""##Get champions with most and less winrate"""

numberGamesPerChamp = dict(champsFiltered)

championWins = []
championLoses = []

for row in game.select("teams", "participants").collect() :
  teamwin = 0
  teamlose = 0
  for team in row['teams']: #2 iterations
    if(team['win'] == 'Win'):
      teamwin = team['teamId']
    else :
      teamlose = team['teamId']
      
  for participant in row['participants']: #10 iterations
    if(participant['teamId'] == teamwin):
      championWins.append(participant['championId'])
    else:
      championLoses.append(participant['championId'])

winsFiltred = sc.parallelize(championWins).map(lambda word: (word, 1/numberGamesPerChamp[int(word)])).reduceByKey(lambda a,b:a +b).sortBy(lambda x:x[1], ascending=False).collect()
losesFiltred = sc.parallelize(championLoses).map(lambda word: (word, 1/numberGamesPerChamp[int(word)])).reduceByKey(lambda a,b:a +b).sortBy(lambda x:x[1], ascending=False).collect()

mostWinChamp = idchampions[str(winsFiltred[0][0])]
mostLosesChamp = idchampions[str(losesFiltred[0][0])]

winrate = "{0:.2f}".format(winsFiltred[0][1] * 100)
lossrate = "{0:.2f}".format(losesFiltred[0][1] * 100)

print("Most winrate:   " + mostWinChamp + " " + str(winrate) + "% winrate")
print("Most loss rate: " + mostLosesChamp + " " + str(lossrate) + "% loss rate")

for i in range(len(winsFiltred)):
  wRateChamp = idchampions[str(winsFiltred[i][0])]
  wRateValue = "{0:.2f}".format(winsFiltred[i][1] * 100)
  print(wRateChamp + " " + str(wRateValue) + "% winrate")

"""##Get champion that killed most and died most"""

killperchamp = [(df['championId'],int(df['stats']['kills'])) for row in game.select("participants").collect() for df in row['participants']]
deathsperchamp = [(df['championId'],int(df['stats']['deaths'])) for row in game.select("participants").collect() for df in row['participants']]

killperchampFiltered = sc.parallelize(killperchamp).reduceByKey(lambda a,b:a +b).sortBy(lambda x:x[1], ascending=False).collect()
deathsperchampFiltered = sc.parallelize(deathsperchamp).reduceByKey(lambda a,b:a +b).sortBy(lambda x:x[1], ascending=False).collect()

print("Champion with more kills  -  " + idchampions[str(killperchampFiltered[0][0])] + " " + str(killperchampFiltered[0][1]) + " kills " + "{0:.2f}".format(int(killperchampFiltered[0][1])/numberGamesPerChamp[killperchampFiltered[0][0]]) + " kill/game (" + str(numberGamesPerChamp[killperchampFiltered[0][0]])  + " games)")
print("Champion with more deaths -  " + idchampions[str(deathsperchampFiltered[0][0])] + " " + str(deathsperchampFiltered[0][1]) + " deaths " + "{0:.2f}".format(int(deathsperchampFiltered[0][1])/numberGamesPerChamp[deathsperchampFiltered[0][0]]) + " death/game (" + str(numberGamesPerChamp[deathsperchampFiltered[0][0]])  + " games)")

"""##Team color with most winrate"""

blueWinRates = 0
for gamesito in game.select('teams').collect():
  if(gamesito['teams'][0]['win'] == 'Win'):
    blueWinRates += 1

print("Blue side winrate: " + str(blueWinRates) + " wins - " + "{0:.2f}".format(blueWinRates*100/game.count()) + "%") 
print("Red side winrate:  " + str(game.count() - blueWinRates) + " wins - " + "{0:.2f}".format((game.count() - blueWinRates)*100/game.count())  + "%")

"""##Top champs with most first kill"""

firstBloodChamps = []

for part in game.select(explode('participants')).collect():
   if(part['col']['stats']['firstBloodKill']):
    firstBloodChamps.append(part['col']['championId'])

firstBloodTop = sc.parallelize(firstBloodChamps).map(lambda word: (word, 1)).reduceByKey(lambda a,b:a +b).sortBy(lambda x:x[1], ascending=False).collect()

plt.xlabel("Champion")
plt.ylabel("Number of kills")

topChamps = 10

x = np.array([i+1 for i in range(topChamps)])

my_xticks = [idchampions[str(firstBloodTop[i][0])] for i in range(topChamps)]
plt.xticks(x, my_xticks)

for i in range(topChamps):
  plt.bar(i+1, firstBloodTop[i][1], width=0.8, align='center' )

fig_size = plt.rcParams["figure.figsize"]
fig_size[0] =5
fig_size[1] =10
plt.rcParams["figure.figsize"] = fig_size
plt.legend(bbox_to_anchor=(1.05,1), loc=2, borderaxespad=0)
plt.show()

for i in range(len(firstBloodTop)):
  print("Top " + str(i+1) + ": " + idchampions[str(firstBloodTop[i][0])] + " with " + str(firstBloodTop[i][1]))

"""##When there are more games played"""

from datetime import datetime
import time

datesCount = {}
datesCount['mati'] = 0
datesCount['migdia'] = 0
datesCount['tarda'] = 0
datesCount['nit'] = 0

#8 - 12 matÃ­ 
#13 - 15 migdia
#16 - 21 tarda
#22 - 7 nit

for row in game.select("gameCreation").collect():
  date = datetime.fromtimestamp(row['gameCreation']/1000.0)
  print(date.strftime('%Y-%m-%d %H:%M:%S'))
  h = date.hour
  if(h>= 8 and h<= 12):
    datesCount['mati'] = datesCount['mati'] + 1
  elif(h>=13 and h<=15):
    datesCount['migdia'] = datesCount['migdia'] + 1
  elif(h>=16 and h <=21):
    datesCount['tarda'] = datesCount['tarda'] + 1
  else:
    datesCount['nit'] = datesCount['nit'] + 1

game.count()

"""##Get champions with best and worst average of creep/s"""

summonersRiftGames = game = spark.read.json("game.json")
summonersRiftGames.show(1)

champsIds = summonersRiftGames.select(explode('participants.championId').alias('ChampionId'))
creepsPerChamps = summonersRiftGames.select(explode('participants.stats.neutralMinionsKilled').alias('Creeps'))
jngleEnemyPerChamps = summonersRiftGames.select(explode('participants.stats.neutralMinionsKilledEnemyJungle').alias('EnJngle'))
jngleAllyPerChamps = summonersRiftGames.select(explode('participants.stats.neutralMinionsKilledTeamJungle').alias('AllyJngle'))

from pyspark.sql.functions import monotonically_increasing_id, asc, desc

creepsPerChamps = creepsPerChamps.withColumn("id", monotonically_increasing_id())

jngleEnemyPerChamps = jngleEnemyPerChamps.withColumn("id", monotonically_increasing_id())

jngleAllyPerChamps = jngleAllyPerChamps.withColumn("id", monotonically_increasing_id())

tmpDF = creepsPerChamps.join(jngleEnemyPerChamps, "id","full")
creepsDF = tmpDF.join(jngleAllyPerChamps, "id","full")
creepsDF = creepsDF.sort(asc("id")).drop("id")

totalCreeps = creepsDF.withColumn('GameCreeps', sum(creepsDF[col] for col in creepsDF.columns))
totalCreeps = totalCreeps.drop("Creeps")
totalCreeps = totalCreeps.drop("EnJngle")
totalCreeps = totalCreeps.drop("AllyJngle")

totalCreeps = totalCreeps.withColumn("id", monotonically_increasing_id())
champsIds = champsIds.sort(asc("ChampionId"))
champs = champsIds.withColumn("id", monotonically_increasing_id())

champCreeps = champs.join(totalCreeps, "id")
champCreeps = champCreeps.drop("id").sort(asc("ChampionId"))
champCreeps.show(10)

champCreepsDict = {}
maxValue = 0
minValue = 1000
minId = 0
maxId= 0
for row in champCreeps.rdd.collect():
  if not row['ChampionId'] in champCreepsDict:
    champID = row['ChampionId']
    champCreepsDict[champID] = (row['GameCreeps'],1)
  else:
    champID = row['ChampionId']
    creeps = row['GameCreeps']
    creeps = creeps + champCreepsDict.get(row['ChampionId'])[0]
    counter = champCreepsDict.get(row['ChampionId'])[1] + 1
    champCreepsDict[champID] = (creeps,counter)
    
for key in champCreepsDict:
  tupla = champCreepsDict[key]
  value = tupla[0] / tupla[1]
  if(value > maxValue):
    maxValue = value
    maxId = key
  elif(value < minValue):
    minValue = value
    minId = key
  champCreepsDict[key] = value

print("Champion with most avg creeps per games is: " + idchampions[str(maxId)] + " with " + str(maxValue) + " creeps per game")
print("Champion with less avg creeps per games is: " + idchampions[str(minId)] + " with " + str(minValue) + " creeps per game")